<!DOCTYPE HTML>
<html>
<head>
    <!-- google ads -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    <title>OOPS Points</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="description" content="This pointer is a pointer which points to the current object of a class. This is actually a keyword which is used as a pointer which differentiate the current object with global object." />
    <meta name="keywords" content="Sharepoint, Asp.net, Sql Server, Sql, MS Sql, HTML, CSS, XML, Bootstrap, JavaScript, asp, language, tutorial, application, framework, programming, Interview Questions, Powershell Tutorial" />
    <link href="../assets/css/main.css" rel="stylesheet" type="text/css" />
</head>
<body class="is-preload">
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-4466196973375945",
            enable_page_level_ads: true
        });
    </script>
    <amp-auto-ads type="adsense" data-ad-client="ca-pub-4466196973375945">
    </amp-auto-ads>
    <!-- Wrapper -->
    <div id="wrapper">
        <!-- Main -->
        <div id="main">
            <div class="inner">
                <!-- Header -->
                <header id="header">
					<a href="index.html" class="logo"><strong>OOPS Points</strong></a>
					<ul class="icons">
						<li><a href="#" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
						<li><a href="#" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
						<li><a href="#" class="icon fa-snapchat-ghost"><span class="label">Snapchat</span></a></li>
						<li><a href="#" class="icon fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="#" class="icon fa-medium"><span class="label">Medium</span></a></li>
					</ul>
				</header>
                <!-- Banner -->
                <section id="banner">
					<div class="content">
						<p>
                            <b><span>
                            What is &quot;this&quot; pointer?</span></b></p>
                        <p>
                            <span>This pointer is a pointer which points to the current object of a class. 
                            This is actually a keyword which is used as a pointer which differentiate the 
                            current object with global object.</span></p>
                        
                        <p>
                            <b><span>
                            A constructor can be private. True or False</span></b></p>
                        <p>
                            <span>True. A constructor can be private. We can declare a constructor as private.</span></p>
                        
                        <p>
                            <b><span>
                            Name the operators that cannot be overloaded.</span></b></p>
                        <p>
                            <span>&nbsp;sizeof
                            <br />
                            .
                            <br />
                            .*
                            <br />
                            .-&gt;
                            <br />
                            ::
                            <br />
                            ?:</span></p>
                        
                        <p>
                            <b><span>
                            What is the work of a constructor?</span></b></p>
                        <p>
                            <span>&nbsp;Constructor creates and initialises the objects in an application.</span></p>
                        
                        <p>
                            <b><span>
                            Static methods can not use non static members. True or False.</span></b></p>
                        <p>
                            <span>&nbsp;True</span></p>
                        
                        <p>
                            <b><span>
                            Static datamembers should be initialized inside the constructor. True or False.</span></b></p>
                        <p>
                            <span>&nbsp;False. Static datamembers should not be initialised inside constructor.</span></p>
                        
                        <p>
                            <b><span>
                            Why can&#39;t you specify the accessibility modifier for methods inside the 
                            interface?</span></b></p>
                        <p>
                            <span>&nbsp;You are not allowed to specify any accessibility, it&#39;s public by default.</span></p>
                        
                        <p>
                            <b><span>
                            Can you allow class to be inherited, but prevent the method from being 
                            over-ridden?</span></b></p>
                        <p>
                            <span>&nbsp;Yes, just leave the class public and make the method sealed.</span></p>
                        
                        <p>
                            <b><span>
                            Can you prevent your class from being inherited and becoming a base class for 
                            some other classes?</span></b></p>
                        <p>
                            <span>&nbsp;Yes, that&#39;s what keyword sealed in the class definition is for. The 
                            developer trying to derive from your class will get a message: cannot inherit 
                            from Sealed class Whatever BaseClassName. It&#39;s the same concept as final class 
                            in Java.</span></p>
                        
                        <p>
                            <b><span>
                            Can you override private virtual methods?</span></b></p>
                        <p>
                            <span>&nbsp;No, you cannot access private methods in inherited classes.</span></p>
                        
                        <p>
                            <b><span>
                            Can you declare the override method static while the original method is 
                            non-static?</span></b></p>
                        <p>
                            <span>&nbsp;No, you can&#39;t, the signature of the virtual method must remain the same, 
                            only the keyword virtual is changed to keyword override.</span></p>
                        
                        <p>
                            <b><span>
                           What does the keyword virtual mean in the method definition?</span></b></p>
                        <p>
                            <span>&nbsp;The method can be over-ridden.</span></p>
                        <p>
                            </p>
                        
                        <p>
                            <b><span>
                            How&#39;s method overriding different from overloading?</span></b></p>
                        <p>
                            <span>&nbsp;When overriding, you change the method behavior for a derived class. 
                            Overloading simply involves having a method with the same name within the class.</span></p>
                        
                        <p>
                            <b><span>
                            Illustrate Server.Transfer and Response.Redirect?</span></b></p>
                        <p>
                            <span>Server.Transfer, transfers the control of a web page, posting a form data, 
                            while Response.Redirect simply redirects a page to another page, it can not post 
                            a form data to another page. Server.Transfer is more efficient over the 
                            Response.Redirect, because Response.Redirect causes a round trip to server as 
                            the page is processed once again on the client and a request is made to server 
                            there after.
                            <br />
                            But the browser url is not changed in case of Server.Transfer i.e. Browser 
                            history is not modified in using it.</span></p>
                        
                        <p>
                            <b><span>
                            Difference between ASP Session and ASP.NET Session?</span></b></p>
                        <p>
                            <span>&nbsp;Asp.net session supports cookie less session &amp; it can span across 
                            multiple servers.</span></p>
                        <p>
                            <b><span>
                            What is Early binding and late binding?</span></b></p>
                        <p>
                            <span>&nbsp;Calling a non-virtual method, decided at a compile time is known as early 
                            binding. Calling a virtual method (Pure Polymorphism), decided at a runtime is 
                            known as late binding.</span></p>
                        
                        <p>
                            <b><span>
                            Diversities between an abstract method &amp; virtual method ?</span></b></p>
                        <p>
                            <span>&nbsp;An Abstract method does not provide an implementation and forces 
                            overriding to the deriving class (unless the deriving class also an abstract 
                            class), where as the virtual method has an implementation and leaves an option 
                            to override it in the deriving class. Thus Virtual method has an implementation 
                            &amp; provides the derived class with the option of overriding it. Abstract method 
                            does not provide an implementation &amp; forces the derived class to override the 
                            method.</span></p>
                        
                        <p>
                            <b><span>
                            When to Use Abstract Classes and When Interfaces.</span></b></p>
                        <p>
                            <span>If you anticipate creating multiple versions of your component, create an 
                            abstract class. Abstract classes provide a simple and easy way to version your 
                            components. By updating the base class, all inheriting classes are automatically 
                            updated with the change. Interfaces, on the other hand, cannot be changed once 
                            created. If a new version of an interface is required, you must create a whole 
                            new interface.
                            <br />
                            <br />
                            If the functionality you are creating will be useful across a wide range of 
                            disparate objects, use an interface. Abstract classes should be used primarily 
                            for objects that are closely related, whereas interfaces are best suited for 
                            providing common functionality to unrelated classes.
                            <br />
                            <br />
                            If you are designing small, concise bits of functionality, use interfaces. If 
                            you are designing large functional units, use an abstract class.
                            <br />
                            <br />
                            If you want to provide common, implemented functionality among all 
                            implementations of your component, use an abstract class. Abstract classes allow 
                            you to partially implement your class, whereas interfaces contain no 
                            implementation for any members.</span></p>
                         
                        <p>
                            <b><span>
                            What are Constructors ?</span></b></p>
                        <p>
                            <span>Constructors are used for initializing the members of a class whenever an 
                            object is created with the default values for initialization.
                            <br />
                            <br />
                            If no constructor defined then the CLR will provide an implicit constructor 
                            which is called as Default Constructor.
                            <br />
                            <br />
                            A class can have any number of constructors provided they vary with the number 
                            of arguments that are passed, which is they should have different signatures.
                            <br />
                            <br />
                            Constructors do not return a value
                            <br />
                            Constructors can be overloaded</span></p>
                        
                        <p>
                            <b><span>
                            What are the various types of Constructors</span></b></p>
                        <p>
                            <span><b>Public :</b> Accessible to All
                            <br />
                            <b>Private: </b>Those classes in which only static members are there and you 
                            don&#39;t want there objects to be created in any class.
                            <br />
                            <b>Static:</b> Used for initializing only the static members of the class. These 
                            will be invoked for the very first time the class is being loaded on the memory. 
                            They cannot accept any arguments. Static Constructors cannot have any access 
                            modifiers.
                            <br />
                            <b>Intern:</b> implementations of the abstract class to the assembly defining 
                            the class. A class containing an internal constructor cannot be instantiated 
                            outside of the assembly (Namespace).
                            <br />
                            and <b>External</b></span></p>
                         
                        <p>
                            <b><span>
                            What&#39;s the Difference between Interface and Abstract Class</span></b></p>
                        <p>
                            <span>Abstract Class:
                            <br />
                            Have constructors.
                            <br />
                            Not necessarily for the class inheriting it to Implement all the Methods.
                            <br />
                            Doesn&#39;t Support Multiple Inheritance.
                            <br />
                            <br />
                            Where everything is Opposite in the Interfaces.</span></p>
                        
                        <p>
                            <b><span>
                            What can you do to make class available for inheritance but you need to prevent 
                            it&#39;s method to come in inheritance chain?</span></b></p>
                        <p>
                            <span>Well, Declare a class with <b>public </b>access specifier and mark all 
                            it&#39;s method to <b>sealed</b> . As anything which is declared with sealed keyword 
                            cannot be inherited.</span></p>
                        
                        <p>
                            <b><span>
                            What Are Attributes in DotNet?</span></b></p>
                        <p>
                            <span>An Attribute is a declarative tag which can be used to provide information 
                            to the compiler about the behaviour of the C# elements such as classes and 
                            assemblies.
                            <br />
                            C# provides convenient technique that will handle tasks such as performing 
                            compile time operations , changing the behaviour of a method at runtime or maybe 
                            even handle unmanaged code.
                            <br />
                            C# Provides many Built-in Attributes
                            <br />
                            <br />
                            Some Popular ones are
                            <br />
                            <br />
                            - Obsolete
                            <br />
                            - DllImport
                            <br />
                            - Conditional
                            <br />
                            - WebMethod
                        </p>
                        <p>
                            <b><span>
                            Default Access modifiers in C#?</span></b></p>
                        <p>
                            <span>&nbsp;An <b>enum</b> has default modifier as <b><i>public</i> </b>
                            <br />
                            <br />
                            A <b>class</b> has default modifiers as <b><i>private</i> </b>. It can declare 
                            members (methods etc) with following access modifiers:
                            <br />
                            public
                            <br />
                            internal
                            <br />
                            private
                            <br />
                            protected internal
                            <br />
                            <br />
                            An <b>interface </b>has default modifier as <b><i>public</i></b>
                            <br />
                            <br />
                            A <b>struct </b>has default modifier as <b><i>private </i></b>and it can declare 
                            its members (methods etc) with following access modifiers:
                            <br />
                            public
                            <br />
                            internal
                            <br />
                            private
                            <br />
                            <br />
                            A <b>methods, fields, and properties</b> has default access modifier as 
                            &quot;Private&quot; if no modifier is specified.</span></p>
                        
                        <p>
                            <b><span>
                            What is Polymorphism?</span></b></p>
                        <p>
                            <span>In OPP’S, polymorphism(Greek meaning “having multiple forms”) is the 
                            ablity of being able to assign a different meaning or usage to something in 
                            different contexts - specifically, to allow an entity such as a a function, or 
                            an object to have more than one forms.
                            <br />
                            <br />
                            In C# :
                            <br />
                            Parent classes may define and implement “virtual” methods(Which is done using 
                            the “virtual” keyword), and derived classes can override them(using the 
                            “override” keyword), which means they provide their own definition and 
                            implementation.At run-time, when user’s code calls the method, the CLR looks up 
                            the run-time type of the object, and invokes that override of the virtual 
                            method. Thus in your source code when a method of the base class is called it 
                            executes the overriden method.
                            <br />
                            ====================================================
                            <br />
                            Regards Hefin Dsouza.</span></p>
                        
                        <p>
                            <b><span>
                            Can we declare private class in a Namespace?</span></b></p>
                        <p>
                            <span>No. If you try to create a private class in a Namespace, Compiler will 
                            throw a compile time error “Namespace elements cannot be explicitly declared as 
                            private, protected, or protected internal”.
                            <br />
                            <br />
                            Reason: The message says it all. Classes can only be declared as private, 
                            protected or protected internal when declared as nested classes, other than 
                            that, it doesn&#39;t make sense to declare a class with a visibility that makes it 
                            unusable, even in the same module. Top level classes cannot be private, they are 
                            &quot;internal&quot; by default, and you can just make them public to make them visible 
                            from outside your DLL.</span></p>
                        
                        <p>
                            <b><span>
                            What is a private constructor? Where will you use it?</span></b></p>
                        <p>
                            <span>When you declare a Constructor with Private access modifier then it is 
                            called Private Constructor. We can use the private constructor in singleton 
                            pattern.
                            <br />
                            <br />
                            If you declare a Constructor as private then it doesn’t allow to create object 
                            for its derived class, i.e you loose inherent facility for that class.
                            <br />
                            <br />
                            Example: </span>
                        </p>
                         
                            <span>Class A</span> 
                        
                            <span>
                            <br />
                            {</span>
                        
                            <span>
                            <br />
                            // some code</span> 
                        
                            <span>
                            <br />
                            &nbsp;Private Void A()</span> 
                        
                            <span>
                            <br />
                            &nbsp;{</span> 
                        
                            <span>
                            <br />
                            &nbsp;//Private Constructor</span> 
                         
                            <span>
                            <br />
                            &nbsp;}</span> 
                       
                            <span>
                            <br />
                            }</span> 
                        
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        
                            <span>
                            <br />
                            Class B:A</span> 
                            <span>
                            <br />
                            {</span> 
                            <span>
                            <br />
                            //code</span> 
                            <span>
                            <br />
                            }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        
                            <span>
                            <br />
                            B obj = new B();// will give Compilation Error</span> 
                            <span>
                            <br />
                            <br />
                            Because Class A constructor declared as private hence its accessibility limit is 
                            to that class only, Class B can&#39;t access. When we create an object for Class B 
                            that constructor will call constructor A but class B have no rights to access 
                            the Class A constructor hence we will get compilation error.</span> 
                            <b><span>
                            Difference between new and override keyword?</span></b> 
                            <span>Let me explain this through code. </span>
                         
                            <span>using System;</span> 
                            <span>
                            <br />
                            using System.Data;</span> 
                            <span>
                            <br />
                            using System.Text;</span> 
                            <span>
                            <br />
                            using System.Windows.Forms;</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        
                            <span>
                            <br />
                            namespace BaseDerive</span> 
                            <span>
                            <br />
                            {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; public partial class Form1 : Form</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Form1()</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InitializeComponent();</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private void Form1_Load(object sender, EventArgs e)</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseClass b = new BaseClass();</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b.func1();</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeriveClass d = new DeriveClass();</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d.func1();</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                       
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Calls Base class function 1 as new 
                            keyword is used.</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseClass bd = new DeriveClass();</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bd.func1();</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Calls Derived class function 2 as 
                            override keyword is used.</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BaseClass bd2 = new DeriveClass();</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bd2.func2();</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; public class BaseClass</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void func1()</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(&quot;Base Class function 
                            1.&quot;);</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public virtual void func2()</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(&quot;Base Class function 
                            2.&quot;);</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
&nbsp; public void func3()</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(&quot;Base Class function 
                            3.&quot;);</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; public class DeriveClass : BaseClass</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public new void func1()</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(&quot;Derieve Class fuction 1 
                            used new keyword&quot;);</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public override void func2()</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(&quot;Derieve Class fuction 2 
                            used override keyword&quot;);</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
                            public void func3()</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageBox.Show(&quot;Derieve Class fuction 3 
                            used override keyword&quot;);</span> 
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                         
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; }</span> 
                            <span>
                            <br />
                            }</span> 
                            <span>
                            <br />
                            <br />
                            <br />
                            This is a window application so all the code for calling the function through 
                            objects is written in Form_Load event.
                            <br />
                            As seen in above code, I have declared 2 classes. One works as a Base class and 
                            second is a derieve class derived from base class.
                            <br />
                            <br />
                            Now the difference is
                            <br />
                            <br />
                            <b>new: hides the base class function.
                            <br />
                            Override: overrides the base class function.</b> </span>
                        
                            <span>BaseClass objB = new DeriveClass();</span> 
                            <span>
                            <br />
                            <br />
                            If we create object like above notation and make a call to any function which 
                            exists in base class and derive class both, then it will always make a call to 
                            function of base class. If we have overidden the method in derive class then it 
                            wlll call the derive class function.
                            <br />
                            <br />
                            For example… </span>
                        
                            <span>objB.func1(); //Calls the base class function. (In case of new keyword)</span> 
                            <span>
                            <br />
                            objB.func2(); //Calls the derive class function. (Override)</span> 
                            <span>
                            <br />
                            objB.func3(); //Calls the base class function.(Same prototype in both the 
                            class.)</span> 
                       
                            <span>
                            <br />
                            Note:
                            <br />
                            // This will throw a compile time error. (Casting is required.) 
                            </span>
                         
                        <p>
                            <span>DeriveClass objB = new BaseClass(); </span>
                         
                            <span>
                            <br />
                            <br />
                            //This will throw run time error. (Unable to cast) </span>
                        </p>
                        <p>
                            <span>DeriveClass objB = (DeriveClass) new BaseClass(); </span>
                        
                            <span>
                            <br />
                            <br />
                            Hope this helps!!!!!</span></p>
                        
                        <p>
                            <b><span>
                            In which cases you use override and new base?</span></b></p>
                        <p>
                            <span>Use the new modifier to explicitly hide a member inherited from a base 
                            class. To hide an inherited member, declare it in the derived class using the 
                            same name, and modify it with the new modifier.</span></p>
                        
                        <p>
                            <b><span>
                            Can we call a base class method without creating instance?</span></b></p>
                        
                        <p>
                            <span>Yep. But ..
                            <br />
                            <br />
                            * Its possible If its a static method.
                            <br />
                            <br />
                            * Its possible by inheriting from that class also.
                            <br />
                            <br />
                            * Its possible from derived classes using base keyword.</span></p>
                        
                        <p>
                            <b><span>
                            What is Method Overriding? How to override a function in C#?</span></b></p>
                        <p>
                            <span>Use the override modifier to modify a method, a property, an indexer, or 
                            an event. An override method provides a new implementation of a member inherited 
                            from a base class. The method overridden by an override declaration is known as 
                            the overridden base method. The overridden base method must have the same 
                            signature as the override method.
                            <br />
                            <br />
                            You cannot override a non-virtual or static method. The overridden base method 
                            must be virtual, abstract, or override.</span></p>
                        
                        <p>
                            <b><span>
                            What is Method overloading?</span></b></p>
                        <p>
                            <span>Method overloading occurs when a class contains two methods with the same 
                            name, but different signatures.</span></p>
                        
                        <p>
                            <b><span>
                            What is overriding?</span></b></p>
                        <p>
                            <span>Method overriding is a feature that allows to invoke functions (that have 
                            the same signatures) and that belong to different classes in the same hierarchy 
                            of inheritance using the base class reference. In C# it is done using keywords
                            <b>virtual</b> and <b>overrides. </b></span>
                            </p>
                        
                        <p>
                            What is method overloading?</span></b></p>
                        <p>
                            <span>Method overloading allows us to write different version of the same method 
                            in a class or derived class. Compiler automatically select the most appropriate 
                            method based on the parameter supplied. </span>
                        </p>
                        <p>
                            <span>public class MultiplyNumbers</span></p>
                        <p>
                            <span>
                            <br />
                            {</span></p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; public int Multiply(int a, int b)</span></p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; {</span></p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a * b;</span></p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; }</span></p>
                        <p>
                            <span>
                            <br />
                            <![if !supportLineBreakNewLine]>
                            <br />
                            <![endif]></span>
                        </p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; public int Multiply(int a, int b, int c)</span></p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; {</span></p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a*b*c;</span></p>
                        <p>
                            <span>
                            <br />
&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp; </span>
                        </p>
                        <p>
                            <span>
                            <br />
                            }</span></p>
                        <p>
                            <span>
                            <br />
                            <br />
                            To call the above method, you can use following code. </span>
                        </p>
                        <p>
                            <span>MultiplyNumbers mn = new MultiplyNumbers();</span></p>
                        <p>
                            <span>
                            <br />
                            int number = mn.Multiply(2, 3) // result = 6</span></p>
                        <p>
                            <span>
                            <br />
                            int number1 = mn.Multiply(2, 3, 4) // result = 24</span></p>
                        <p>
                            </p>
                        <p>
                            <span>
                            <br />
                            <br />
                            You can&#39;t have a overload method with same number parameters but different 
                            return type. In order to create overload method, the return type must be the 
                            same and parameter type must be different or different in numbers.</span></p>
                        
                        <p>
                            <b><span>
                            What is Protected Internal access modifier in C#?</span></b></p>
                        <p>
                            <span>Protected Internal is a access modifiers for the members (methods or 
                            functions) ie. you can&#39;t declare a class as protected internal explicitly. The 
                            members access is limited to the current assembly or types derived from the 
                            containing class.
                            <br />
                            <br />
                            Protected Internal means the method is accessible by anything that can access 
                            the protected method UNION with anything that can access the internal method.
                            </span></p>
                       
                        <p>
                            <b><span>
                            What is Abstract Class?</span></b></p>
                        <p>
                            <span>Abstract class is a class that can not be instantiated, it exists 
                            extensively for inheritance and it must be inherited. There are scenarios in 
                            which it is useful to define classes that is not intended to instantiate; 
                            because such classes normally are used as base-classes in inheritance 
                            hierarchies, we call such classes abstract classes.
                            <br />
                            <br />
                            Abstract classes cannot be used to instantiate objects; because abstract classes 
                            are incomplete, it may contain only definition of the properties or methods and 
                            derived classes that inherit this implements it&#39;s properties or methods.
                            <br />
                            <br />
                            Static, Value Types &amp; interface doesn&#39;t support abstract modifiers. Static 
                            members cannot be abstract. Classes with abstract member must also be abstract.
                            
                            </span>
                        </p>
                        
                        <p>
                            <b><span>
                            Can we specify the access modifier for explicitly implemented interface method?</span></b></p>
                        <p>
                            <span>No, we can&#39;t specify the access modifier for the explicitly implemented 
                            interface method. By default its scope will be internal.</span></p>
                        
                        <p>
                            <b><span>
                            What is Protected access modifier in C#?</span></b></p>
                        <p>
                            <span>The protected keyword is a member access modifier. It can only be used in 
                            a declaring a function or method not in the class ie. a class can&#39;t be declared 
                            as protected class.
                            <br />
                            <br />
                            A protected member is accessible from within the class in which it is declared, 
                            and from within any class derived from the class that declare this member. In 
                            other words access is limited to within the class definition and any class that 
                            inherits from the class
                            <br />
                            <br />
                            A protected member of a base class is accessible in a derived class only if the 
                            access takes place through the derived class type.
                            </p>
                        <p>
                            <b><span>
                            What is Internal access modifier in C#?</span></b></p>
                        <p>
                            <span>The internal keyword is an access modifier for types and type members ie. 
                            we can declare a class as internal or its member as internal. Internal members 
                            are accessible only within files in the same assembly (.dll). In other words, 
                            access is limited exclusively to classes defined within the current project 
                            assembly.
                            </span></p>
                        
                        <p>
                            <b><span>
                            What is Private access modifier in C#?</span></b></p>
                        <p>
                            <span>The private keyword is a member access modifier ie. we can&#39;t explicitly 
                            declare a class as Private, however if do not specify any access modifier to the 
                            class, its scope will be assumed as Private. Private access is the least 
                            permissive access level of all access modifiers.
                            <br />
                            <br />
                            Private members are accessible only within the body of the class or the struct 
                            in which they are declared. This is the default access modifier for the class 
                            declaration.
                            </span></p>
                        
                        <p>
                            <b><span>
                            What is Public access modifier in C#?</span></b></p>
                        <p>
                            <span>The public keyword is an access modifier for types and type members ie. we 
                            can declare a class or its member (functions or methods) as Public. There are no 
                            restrictions on accessing public members.</span></p>
                        
                        <p>
                            <b><span>
                            What is pure virtual function?</span></b></p>
                        <p>
                            <span>When you define only function prototype in a base class without and do the 
                            complete implementation in derived class. This base class is called abstract 
                            class and client won’t able to instantiate an object using this base class.
                            <br />
                            <br />
                            A pure virtual function is a function that must be overridden in a derived class 
                            and need not be defined. A virtual function is declared to be &quot;pure&quot; using the 
                            curious &quot;=0&quot;
                            <br />
                            syntax:
                            <br />
                            class Base {
                            <br />
                            public:
                            <br />
                            void f1(); // not virtual
                            <br />
                            virtual void f2(); // virtual, not pure
                            <br />
                            virtual void f3() = 0; // pure virtual
                            <br />
                            };</span></p>
                        
                        <p>
                            <b><span>
                            When to use Interface over abstract class?</span></b></p>
                        <p>
                            <span>Abstract Classes: Classes which cannot be instantiated. This means one 
                            cannot make a object of this class or in other way cannot create object by 
                            saying ClassAbs abs = new ClassAbs(); where ClassAbs is abstract class.
                            <br />
                            Abstract classes contains have one or more abstarct methods, ie method body only 
                            no implementation.
                            <br />
                            Interfaces: These are same as abstract classes only difference is we can only 
                            define method definition and no implementation.
                            <br />
                            When to use wot depends on various reasons. One being design choice.
                            <br />
                            One reason for using abstarct classes is we can code common
                            <br />
                            functionality and force our developer to use it. I can have a complete
                            <br />
                            class but I can still mark the class as abstract.
                            <br />
                            Developing by interface helps in object based communication.</span></p>
                        
                        <p>
                            <b><span>
                            What is Sealed modifiers?</span></b></p>
                        <p>
                            <span>Sealed types cannot be inherited &amp; are concrete.
                            <br />
                            Sealed modifiers can also be applied to instance methods, properties, events &amp; 
                            indexes. It can&#39;t be applied to static members.
                            <br />
                            <br />
                            Sealed members are allowed in sealed and non-sealed classes.</span></p>
                        
                        <p>
                            <b><span>
                            What is New modifiers?</span></b></p>
                        <p>
                            <span>The new modifiers hides a member of the base class. C# supports only hide 
                            by signature.</span></p>
                        
                        <p>
                            <b><span>
                            What is Virtual keyword?</span></b></p>
                        <p>
                            <span>This keyword indicates that a member can be overridden in a child class. 
                            It can be applied to methods, properties, indexes and events.</span></p>
                        
                        <p>
                            <b><span>
                            What is an Interface?</span></b></p>
                        <p>
                            <span>An interface is a contract &amp; defines the requisite behavior of 
                            generalization of types.
                            <br />
                            <br />
                            An interface mandates a set of behavior, but not the implementation. Interface 
                            must be inherited. We can&#39;t create an instance of an interface.
                            <br />
                            <br />
                            An interface is an array of related function that must be implemented in derived 
                            type. Members of an interface are implicitly public &amp; abstract.
                            <br />
                            <br />
                            An interface can inherit from another interface.</span></p>
                        
                        <p>
                            <b><span>
                            What is Inheritance?</span></b></p>
                        <p>
                            <span>It provides a convenient way to reuse existing fully tested code in 
                            different context thereby saving lot of coding.
                            <br />
                            <br />
                            Inheritance of classes in C# is always implementation Inheritance.</span></p>
                         
                        <p>
                            <b><span>
                             What is Abstract method?</span></b></p>
                        <p>
                            <span>Abstract method doesn&#39;t provide the implementation &amp; forces the derived 
                            class to override the method.</span></p>
                         
                        <p>
                            <b><span>
                             What is Static Method?</span></b></p>
                        <p>
                            <span>It is possible to declare a method as Static provided that they don&#39;t 
                            attempt to access any instance data or other instance methods.</span></p>
                         
                        <p>
                            <b><span>
                             What is Static field?</span></b></p>
                        <p>
                            <span>To indicate that a field should only be stored once no matter how many 
                            instance of the class we create.</span></p>
                         
                        <p>
                            <b><span>
                             What is Class?</span></b></p>
                        <p>
                            <span>A Class is the generic definition of what an object is a template.
                            <br />
                            <br />
                            The keyword class in C# indicates that we are going to define a new class (type 
                            of object)</span></p>
                         
                        <p>
                            <b><span>
                             What is Object?</span></b></p>
                        <p>
                            <span>Object is anything that is identifiable as a single material item.</span></p>
                         
                        <p>
                            <b><span>
                             Can Struct be inherited?</span></b></p>
                        <p>
                            <span>No, Struct can&#39;t be inherited as this is implicitly sealed.</span></p>
                         
                        <p>
                            <b><span>
                             What is Virtual method?</span></b></p>
                        <p>
                            <span>Virtual Method has implementation &amp; provide the derived class with the 
                            option to override it.</span></p>
                         <p>
                            <b><span>
                             What is Polymorphisms?</span></b></p>
                        <p>
                            <span>Polymorphism means one interface and many forms. Polymorphism is a 
                            characteristics of being able to assign a different meaning or usage to 
                            something in different contexts specifically to allow an entity such as a 
                            variable, a function or an object to have more than one form.
                            <br />
                            <br />
                            There are two types of Polymorphism.
                            <br />
                            <b>Compile time:</b> function or operator overloading
                            <br />
                            <b>Runtime:</b> Inheritence &amp; virtual functions</span></p>
						<p>
                        
                        </p>
                    </div>
				</section>
            </div>
        </div>
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="inner">
                <!-- Logo -->
                <section id="search" class="alt">
					<header>
							<h4><a href="http://softwaredevelopersolution.com">Software Developer Solution</a></h4>
						</header>
				</section>
                <!-- Menu -->
                <nav id="menu">
					<header class="major">
						<h2>Menu</h2>
					</header>
					<ul>
						<li>
							<span class="opener active">ASP.NET</span>
							<ul>
								<li><a href="/aspnet/index.html">asp.net</a></li>
                                <li><a href="/aspnet/OOPSPoints.html">OOPS Points</a></li>
                                <li><a href="/aspnet/ADONETPoints.html">ADO NET Points</a></li>
                                <li><a href="/aspnet/AJAXPoints.html">AJAX Points</a></li>
                                <li><a href="/aspnet/FILTERandSORTrecords.html">FILTER and SORT records</a></li>
							</ul>
						</li>
                        <li><a href="/sharepoint/index.html">sharepoint</a></li>
                        <li><a href="/sql/index.html">sql</a></li>
                        <li><a href="/Powershell/index.html">Powershell</a></li>
                        <li><a href="/html/index.html">html</a></li>
                        <li><a href="/css/index.html">css</a></li>
                        <li><a href="/javascript/index.html">java script</a></li>
                        <li><a href="/bootstrap/index.html">bootstrap</a></li>
                        <li><a href="/jquery/index.html">jquery</a></li>
                        <li><a href="/IQ/index.html">Interview Question</a></li>                       
					</ul>
				</nav>
                <!-- Footer -->
                <footer id="footer">
					<p class="copyright">&copy; All rights reserved. <a href="http://softwaredevelopersolution.com">Software Developer Solution</a>.</p>
				</footer>
            </div>
        </div>
    </div>
    <!-- Scripts -->
    <script src="/../assets/js/jquery.min.js"></script>
    <script src="/../assets/js/browser.min.js"></script>
    <script src="/../assets/js/breakpoints.min.js"></script>
    <script src="/../assets/js/util.js"></script>
    <script src="/../assets/js/main.js"></script>
</body>
</html>
