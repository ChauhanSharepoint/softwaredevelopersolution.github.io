<!DOCTYPE HTML>
<html>
<head>
    <!-- google ads -->
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
    <title>Triggers in SQL SERVER</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="description" content="Triggers are special types of Stored Procedures that are defined to execute automatically in place of or after data modifications. They can be executed automatically on the INSERT, DELETE and UPDATE triggering actions." />
    <meta name="keywords" content="Sharepoint, Asp.net, Sql Server, Sql, MS Sql, HTML, CSS, XML, Bootstrap, JavaScript, asp, language, tutorial, application, framework, programming, Interview Questions, Powershell Tutorial" />
    <link href="../assets/css/main.css" rel="stylesheet" type="text/css" />
</head>
<body class="is-preload">
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-4466196973375945",
            enable_page_level_ads: true
        });
    </script>
    <amp-auto-ads type="adsense" data-ad-client="ca-pub-4466196973375945">
    </amp-auto-ads>
    <!-- Wrapper -->
    <div id="wrapper">
        <!-- Main -->
        <div id="main">
            <div class="inner">
                <!-- Header -->
                <header id="header">
					<a href="index.html" class="logo"><strong>Triggers in SQL SERVER</strong></a>
					<ul class="icons">
						<li><a href="#" class="icon fa-twitter"><span class="label">Twitter</span></a></li>
						<li><a href="#" class="icon fa-facebook"><span class="label">Facebook</span></a></li>
						<li><a href="#" class="icon fa-snapchat-ghost"><span class="label">Snapchat</span></a></li>
						<li><a href="#" class="icon fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="#" class="icon fa-medium"><span class="label">Medium</span></a></li>
					</ul>
				</header>
                <!-- Banner -->
                <section id="banner">
					<div class="content">
						
                        <h1>Implementing Triggers in SQL Server 2000</h1>
                        
                        <p>
                            Triggers are special types of Stored Procedures that are defined to execute 
                            automatically in place of or after data modifications. They can be executed 
                            automatically on the INSERT, DELETE and UPDATE triggering actions.</p>
                        <p>
                            There are two different types of triggers in Microsoft SQL Server 2000. They are 
                            INSTEAD OF triggers and AFTER triggers. These triggers differ from each 
                            other in terms of their purpose and when they are fired. In this article we 
                            shall discuss each type of trigger.</p>
                        <p>
                            First of all, let&#39;s create a sample database with some tables and insert some 
                            sample data in those tables using the script below:</p>
                        <h1>
                            Brief about Triggers in SQL Server 2000</h1>
                        <p>
                            A trigger is a database object that is bound to a table. In many aspects, it is 
                            similar to a stored procedure. As a matter of fact, triggers are often referred 
                            to as a &quot;special kind of stored procedure&quot;.</p>
                         
                        <h2> Introduction</h2>
                        <p>
                            A trigger is a database object that is bound to a table. In many aspects, it is 
                            similar to a stored procedure. As a matter of fact, triggers are often referred 
                            to as a &quot;special kind of stored procedure&quot;.</p>
                        <h2>
                            When to Use Triggers</h2>
                        <p>
                            There are many reasons to use triggers. If you have a table which keeps a log of 
                            messages, you may want to have a copy of them mailed to you if they are urgent. 
                            If there were no triggers, you would have some solutions, though they are not as 
                            elegant. You could modify the application(s) logging the messages. This means 
                            that you might be redundantly coding the same thing in every application that 
                            logs messages.</p>
                        <p>
                            Tables can have multiple triggers. The CREATE TRIGGER statement can be defined with the FOR
                            UPDATE, FOR
                            INSERT, or
                            FOR
                            DELETE clauses to target a 
                            trigger to a specific class of data modification actions. When
                            FOR
                            UPDATE is specified, the
                            IF
                            UPDATE<code> (column_name)</code> 
                            clause can be used to target a trigger to updates affecting a particular column.</p>
                        <p>
                            SQL Server 2000 greatly enhances trigger functionality, extending the 
                            capabilities of the triggers you already know and love, and adding a whole new 
                            type of trigger, the &quot;<code>Instead </code>Of&quot; 
                            trigger.</p>
                        <p>
                            SQL Server 2000 has many types of triggers:</p>
                        <ol start="1" type="1">
                            <li>After Trigger </li>
                            <li>Multiple After Triggers </li>
                            <li>Instead Of Triggers </li>
                            <li>Mixing Triggers Type </li>
                        </ol>
                        <h2>
                            After Triggers</h2>
                        <p>
                            Triggers that run after an update,
                            insert, or
                            delete can be used in several 
                            ways:</p>
                        <ul type="disc">
                            <li>Triggers can update, insert, or delete data in the same or 
                                other tables. This is useful to maintain relationships between data or to keep 
                                audit trail information. </li>
                            <li>Triggers can check data against values of data in the rest of 
                                the table or in other tables. This is useful when you cannot use RI constraints 
                                or check constraints because of references to data from other rows from this or 
                                other tables. </li>
                            <li>Triggers can use user-defined functions to activate 
                                non-database operations. This is useful, for example, for issuing alerts or 
                                updating information outside the database. </li>
                        </ul>
                        <p>
                            <b>Note</b>: An <code>AFTER</code> trigger can be created only on tables, not on 
                            views.</p>
                        <h3>
                            How to Create After Triggers</h3>
                        <ol start="1" type="1">
                            <li>Working with INSERT 
                                Triggers </li>
                        </ol>
                        
                        <pre><span>INSERT</span> <span>INTO</span> Customers </pre>
                        <pre><span>VALUES</span> (<span>'Mayank','Gupta','Hauz Khas','Delhi',</span></pre>
                        <pre><span>              'Delhi','110016','01126853138')</span></pre>
                        <pre><span>INSERT</span> <span>INTO</span> Customers </pre>
                        <pre><span>VALUES</span>(<span>'Himanshu','Khatri','ShahjahanMahal ',</span></pre>
                        <pre><span>  'Jaipur','Rajesthan','326541','9412658745')</span></pre>
                        <pre><span>INSERT</span> <span>INTO</span> Customers </pre>
                        <pre><span>VALUES</span> (<span>'Sarfaraz','Khan','Green Market',</span></pre>
                        <pre><span>   'Hydrabad','AP','698542','9865478521')</span></pre>
                        <pre> </pre>
                        <pre><span>INSERT</span> <span>INTO</span> Products</pre>
                        <pre><span>VALUES</span> (<span>'ASP.Net Microsoft Press',</span><span 
                            class="code-digit">550</span>)</pre>
                        <pre><span>INSERT</span> <span>INTO</span> Products</pre>
                        <pre><span>VALUES</span> (<span>'ASP.Net Wrox Publication',</span><span 
                            class="code-digit">435</span>)</pre>
                        <pre><span>INSERT</span> <span>INTO</span> Products</pre>
                        <pre><span>VALUES</span> (<span>'ASP.Net Unleased',</span><span 
                            class="code-digit">320</span>)</pre>
                        <pre><span>INSERT</span> <span>INTO</span> Products</pre>
                        <pre><span>VALUES</span> (<span>'ASP.Net aPress',</span><span 
                            class="code-digit">450</span>)</pre>
                        <pre> </pre>
                        <pre><span>CREATE</span> <span>TRIGGER</span> invUpdate <span 
                           >ON</span> [Orders]</pre>
                        <pre><span>FOR</span> <span>INSERT</span></pre>
                        <pre><span>AS</span></pre>
                        <pre><span>UPDATE</span> p <span>SET</span> p.instock=[p.instock <span>' i.qty]</span></pre>
                        <pre><span>FROM</span> products p <span 
                           >JOIN</span> inserted I <span>ON</span> p.prodid = i.prodid</pre>
                        <p>
                            You created INSERT trigger that 
                            referenced the logical inserted table. Whenever you insert a new record in the 
                            Orders table now, the corresponding record in the Products table will be updated 
                            to subtract the quantity of the order from the quantity on hand in the <i>
                            instack</i> column of the Products table.</p>
                        <ol start="2" type="1">
                            <li>Working with DELETE 
                                Triggers </li>
                        </ol>
                        <p>
                            DELETE triggers are used for 
                            restricting the data that your users can remove from a database. For example:</p>
                       
                        <pre><span>CREATE</span> <span>TRIGGER</span> DelhiDel <span 
                           >ON</span> [Customers]</pre>
                        <pre><span>FOR</span> <span>DELETE</span></pre>
                        <pre><span>AS</span></pre>
                        <pre><span>IF</span> (<span>SELECT</span> state <span 
                           >FROM</span> deleted) = <span>'Delhi'</span></pre>
                        <pre><span>BEGIN</span></pre>
                        <pre><span>PRINT</span> <span>'Can </span><span 
                           >not</span> remove customers <span>from</span> Delhi<span>'</span></pre>
                        <pre><span>PRINT</span> <span>'Transaction has been canceled'</span></pre>
                        <pre>ROOLBACK</pre>
                        <pre><span>END</span></pre>
                        <p>
                            DELETE trigger uses the logical 
                            deleted table to make certain that you were not trying to delete a customer from 
                            the great state <span>'Delhi' ' if you did try to delete such a customer, you 
                            would be met with Mayank in the from of an error message (which was generated by 
                            the </span>PRINT statement that 
                            you entered in the trigger code).</p>
                        <ol start="3" type="1">
                            <li>Working with UPDATE 
                                Triggers </li>
                        </ol>
                        <p>
                            UPDATE triggers are used to 
                            restrict UPDATE statements issued 
                            by your users, or back your previous data.</p>
                        
                        <pre><span>CREATE</span> <span>TRIGGER</span> CheckStock <span 
                           >ON</span> [Products]</pre>
                        <pre><span>FOR</span> <span>UPDATE</span></pre>
                        <pre><span>AS</span></pre>
                        <pre><span>IF</span> (<span>SELECT</span> InStock <span 
                           >FROM</span> inserted) &lt; <span class="code-digit">0</span></pre>
                        <pre><span>BEGIN</span></pre>
                        <pre><span>PRINT</span> <span>'Cannot oversell Products'</span></pre>
                        <pre><span>PRINT</span> <span>'Transaction has been cancelled'</span></pre>
                        <pre><span>ROLLBACK</span></pre>
                        <pre><span>END</span></pre>
                        <p>
                            You created an UPDATE trigger 
                            that references the inserted table to verify that you are not trying to insert a 
                            value that is less than zero. You need to check only the inserted table because 
                            SQL Server performs any necessary mathematical functions before inserting your 
                            data.</p>
                        <h2>
                            Multiple After Triggers</h2>
                        <p>
                            More than one trigger can now be defined on a table for each
                            Insert/<span 
                               ><span>Update/Delete. 
                            Although in general, you might not want to do this (it&#39;s easy to get confused if 
                            you over-use triggers), there are situations where this is ideal. One example 
                            that springs to mind is that you can split your triggers up into two categories:</p>
                        <ul type="disc">
                            <li>Application based triggers (cascading deletes or validation, 
                                for example). </li>
                            <li>Auditing triggers (for recording details of changes to 
                                critical data). </li>
                        </ul>
                        <p>
                            This would allow you to alter triggers of one type without fear of accidentally 
                            breaking the other.</p>
                        <p>
                            If you are using multiple triggers, it is of course essential to know which 
                            order they fire in. A new stored procedure called <i>sp_settriggerorder</i> 
                            allows you to set a trigger to be either the &quot;first&quot; or &quot;last&quot; to fire.</p>
                        <p>
                            If you want more than two triggers to fire in a specific order, there is no way 
                            to specifically define this. A deeply unscientific test I did indicated that 
                            multiple triggers for the same table and operation will run in the order they 
                            were created unless you specifically tell them otherwise. I would not recommend 
                            relying on this though.</p>
                        <h2>
                            Instead Of Triggers</h2>
                        <p>
                            Instead Of Triggers fire instead of the operation that fires the trigger, so if 
                            you define an Instead Of trigger on a table for the Delete operation, they try to delete rows, they will not 
                            actually get deleted (unless you issue another 
                            delete instruction from within the trigger) as in this simple 
                            example:</p>
                        
                        <pre><span>CREATE</span> <span>TABLE</span> Mayank (Name<span>  </span><span 
                           >varchar</span>(<span class="code-digit">32</span>))</pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>CREATE</span> <span>TRIGGER</span> tr_mayank <span 
                           >ON</span> Mayank </pre>
                        <pre>INSTEAD <span>OF</span> <span>DELETE</span></pre>
                        <pre><span>AS</span></pre>
                        <pre><span>    </span><span>PRINT</span> <span 
                            class="code-string">&#39;Sorry - you cannot delete this data&#39;</span></pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>INSERT</span> Mayank</pre>
                        <pre><span>    </span><span>SELECT</span> <span 
                            class="code-string">&#39;Cannot&#39;</span> <span>union</span></pre>
                        <pre><span>    </span><span>SELECT</span> <span 
                            class="code-string">&#39;Delete&#39;</span> <span>union</span></pre>
                        <pre><span>    </span><span>SELECT</span> <span 
                            class="code-string">&#39;Me&#39;</span></pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>DELETE</span> Mayank</pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>SELECT</span> * <span>FROM</span> Mayank</pre>
                        <pre><span>GO</span></pre>
                        <pre><span>DROP</span> <span>TABLE</span> Mayank</pre>
                        <p>
                            If you were to print out the contents of the inserted and deleted tables from 
                            inside an Instead Of trigger, you would see they behave in exactly the same way 
                            as normal. In this case, the deleted table holds the rows you were trying to 
                            delete, even though they will not get deleted.</p>
                        <p>
                            Instead of Triggers can be used in some very powerful ways!</p>
                        <ul type="disc">
                            <li>You can define an Instead Of trigger on a view (something that 
                                will not work with After triggers) and this is the basis of the Distributed 
                                Partitioned Views that are used so split data across a cluster of SQL Servers. 
                            </li>
                            <li>You can use Instead Of triggers to simplify the process of 
                                updating multiple tables for application developers. </li>
                            <li>Mixing Trigger Types. </li>
                        </ul>
                        <p>
                            If you were to define an Instead Of trigger and an After trigger on the same 
                            table for the same operation, what would happen?</p>
                        <p>
                            Because an After trigger fires after an operation completes, and an &#39;instead of&#39; 
                            trigger prevents the operation from taking place, the After trigger would never 
                            fire in this situation.</p>
                        <p>
                            However, if an Instead Of trigger on a (say) delete operation contains a 
                            subsequent delete on the same table, then any After trigger defined for the 
                            delete operation on that table will fire on the basis of the
                            delete statement issued from the 
                            Instead Of trigger. The original delete 
                            statement is not executed, only the Delete 
                            in the Instead Of trigger runs.</p>
                        <p>
                            This code sample creates a trigger of each type, and changed the nature of the
                            delete statement issued so that 
                            only comics that have a value of 0 in the Preserve column can be deleted.</p>
                        
                        <pre><span>CREATE</span> <span>TABLE</span> Gupta (Comic <span 
                           >VARCHAR</span> (<span class="code-digit">32</span>), Preserve <span 
                           >INT</span>)</pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>INSERT</span> Gupta</pre>
                        <pre><span>    </span><span>SELECT</span> <span 
                            class="code-string">&#39;groucho&#39;</span>, <span class="code-digit">1</span> <span 
                           >UNION</span></pre>
                        <pre><span>    </span><span>SELECT</span> <span 
                            class="code-string">&#39;chico&#39;</span>, <span class="code-digit">1</span> <span 
                           >UNION</span></pre>
                        <pre><span>    </span><span>SELECT</span> <span 
                            class="code-string">&#39;harpo&#39;</span>, <span class="code-digit">0</span> <span 
                           >UNION</span></pre>
                        <pre><span>    </span><span>SELECT</span> <span 
                            class="code-string">&#39;zeppo&#39;</span>, <span class="code-digit">0</span></pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>CREATE</span> <span>TRIGGER</span> trGuptaDelete <span 
                           >ON</span> Gupta </pre>
                        <pre><span>FOR</span> <span>DELETE</span></pre>
                        <pre><span>AS</span></pre>
                        <pre><span>    </span><span>SELECT</span> Comic <span 
                           >AS</span> <span class="code-string">&quot;deleting_these_names_only&quot;</span></pre>
                        <pre><span>    </span><span>FROM</span> deleted</pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>CREATE</span> <span>TRIGGER</span> tr_Gupta_InsteadOf <span 
                           >ON</span> Gupta</pre>
                        <pre>INSTEAD <span>OF</span> <span>DELETE</span></pre>
                        <pre><span>AS</span></pre>
                        <pre><span>    </span><span>DELETE</span> Gupta</pre>
                        <pre><span>    </span><span>FROM</span> Gupta</pre>
                        <pre><span>    </span><span>INNER</span> <span 
                           >JOIN</span> Deleted</pre>
                        <pre><span>    </span><span>ON</span> Gupta.Comic = Deleted.Comic</pre>
                        <pre><span>    </span><span>WHERE</span> Gupta.Preserve= <span 
                            class="code-digit">0</span></pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>DELETE</span> Gupta <span>WHERE</span> Comic <span 
                           >IN</span> (<span class="code-string">&#39;GROUCHO&#39;</span>, <span 
                            class="code-string">&#39;HARPO&#39;</span>)</pre>
                        <pre><span>GO</span></pre>
                        <pre> </pre>
                        <pre><span>SELECT</span> * <span>FROM</span> Gupta</pre>
                        <pre> </pre>
                        <pre><span>DROP</span> <span>TABLE</span> Gupta</pre>
                        <h2>
                            Important</h2>
                        <p>
                            Triggers can be used in the following scenarios, such as: if the database is 
                            de-normalized and requires an automated way to update redundant data contained 
                            in multiple tables, or if customized messages and complex error handling are 
                            required, or if a value in one table must be validated against a non-identical 
                            value in another table.</p>
                        <p>
                            Triggers are a powerful tool that can be used to enforce the business rules 
                            automatically when the data is modified. Triggers can also be used to maintain 
                            the data integrity. But they are not to maintain data integrity. Triggers should 
                            be used to maintain the data integrity only if you are unable to enforce the 
                            data integrity using CONSTRAINTS, RULES, and DEFAULTS. Triggers cannot be 
                            created on the temporary tables.</p>
                        
                        <p>
                            A trigger is a special kind of stored procedure that is invoked whenever an 
                            attempt is made to modify the data in the table it protects. Modifications to 
                            the table are made ussing INSERT,UPDATE,OR DELETE statements.Triggers are used 
                            to enforce data integrity and business rules such as automatically updating 
                            summary data. It allows to perform cascading delete or update operations. If 
                            constraints exist on the trigger table,they are checked prior to the trigger 
                            execution. If constraints are violated statement will not be executed and 
                            trigger will not run.Triggers are associated with tables and they are automatic 
                            . Triggers are automatically invoked by SQL SERVER. Triggers prevent incorrect , 
                            unauthorized,or inconsistent changes to data.</p>
                        <p>
                            <b><span>Creation of Triggers </span></b>
                        </p>
                        <p>
                            <span> 
                            Triggers are created with the CREATE TRIGGER statement. This statement specifies 
                            that the on which table trigger is defined and on which events trigger will be 
                            invoked.<br />
                            <br />
                            To drop Trigger one can use DROP TRIGGER statement.</span></p>
                        <p>
                            <span>Code: SQL</span></p>
                        <div>
                            <p>
                                <b><span>CREATE</span></b><span> <b>TRIGGER</b> [owner.]trigger_name<br />
                                <br />
                                ON[owner.] table_name<br />
                                <br />
                                FOR[INSERT/<b>UPDATE</b>/DELETE] <b>AS</b>
                                <br /> 
                                <b>IF</b> <b>UPDATE</b>(column_name)<br />
                                <br />
                                [{<b>AND</b>/<b>OR</b>} <b>UPDATE</b>(COLUMN_NAME)...]<br />
                                <br />
                                { sql_statements }</span></p>
                        </div>
                        
                        <p>
                            <b><span>Trigger rules and guidelines</span></b></p>
                        <p>
                            <span> 
                            A table can have only three triggers action per table : UPDATE ,INSERT,DELETE. 
                            Only table owners can create and drop triggers for the table.This permission 
                            cannot be transferred.A trigger cannot be created on a view or a temporary table 
                            but triggers can reference them. A trigger should not include SELECT statements 
                            that return results to the user, because the returned results would have to be 
                            written into every application in which modifications to the trigger table are 
                            allowed. They can be used to help ensure the relational integrity of database.On 
                            dropping a table all triggers associated to the triggers are automatically 
                            dropped .<br />
                            <br />
                            <br />
                            The system stored procedure sp_depends can be used to find out which tables have 
                            trigger on them. Following sql statements are not allowed in a trigger they 
                            are:-</span></p>
                        <p>
                            <span>Code: SQL</span></p>
                        <div>
                            <p>
                                <b><span>ALL</span></b><span> <b>CREATE</b> statements,<b>ALL</b> <b>DROP</b> 
                                statements,<b>ALTER</b> <b>TABLE</b> <b>AND</b> <b>ALTER</b> <b>DATABASE</b>,<b>TRUNCATE</b>
                                <b>TABLE</b>,<b>GRANT</b> <b>AND</b> <b>REVOKE</b>,<b>UPDATE</b> 
                                STATISTICS,RECONFIGURE,<b>LOAD</b> <b>DATABASE</b> <b>AND</b> <b>LOAD</b> 
                                TRANSACTION, <b>ALL</b> DISK statements,<b>SELECT</b> <b>INTO</b></span></p>
                        </div> 
                        <p>
                            <b><span>INSERT trigger</span></b></p>
                        <p>
                            <span>
                            <br />
                            <br />
                            When an INSERT trigger statement is executed ,new rows are added to the trigger 
                            table and to the inserted table at the same time. The inserted table is a 
                            logical table that holds a copy of rows that have been inserted. The inserted 
                            table can be examined by the trigger ,to determine whether or how the trigger 
                            action are carried out.<br />
                            <br />
                            The inserted table allows to compare the INSERTED rows in the table to the rows 
                            in the inserted table.The inserted table are always duplicates of one or more 
                            rows in the trigger table.With the inserted table ,inserted data can be 
                            referenced without having to store the information to the variables.</span></p>
                        <p>
                            <b><span>DELETE trigger</span></b></p>
                        <p>
                            <span> 
                            When a DELETE trigger statement is executed ,rows are deleted from the table and 
                            are placed in a special table called deleted table. </span>
                        </p>
                        <p>
                            <b><span>UPDATE trigger</span></b></p>
                        <p>
                            <span> 
                            When an UPDATE statement is executed on a table that has an UPDATE trigger,the 
                            original rows are moved into deleted table,While the update row is inserted into 
                            inserted table and the table is being updated.<br />
                            <br />
                            Syntax </span>
                        </p>
                        <p>
                            <span>Code: SQL</span></p>
                        <div>
                            <p>
                                <b><span>IF</span></b><span> UPDATE&lt;column_name&gt;<br />
                                <b>CREATE</b> <b>TRIGGER</b> trigger1 <b>ON</b> member<br />
                                <b>FOR</b> <b>UPDATE</b><br />
                                <b>AS</b><br />
                                <b>IF</b> <b>UPDATE</b>(last_name)<br />
                                BEGIN<br />
                                RAISEERROR(&#39;Transaction cannot be processed&#39;)<br />
                                ROLLBACK TRANSACTION<br />
                                END</span></p>
                        </div> 
                        <p>
                             <b><span>Multi-row trigger</span></b></p>
                        <p>
                            <span>
                            <br />
                            <br />
                            A multi-row insert can occur from an INSERT with a SELECT statement.Multirow 
                            considerations can also apply to multi-row updates and multi-row deletes.</span></p>
                        <p>
                            <span>Code: SQL</span></p>
                        <div>
                            <p>
                                <b><span>CREATE</span></b><span> <b>TRIGGER</b> adult_insert <b>ON</b> adult
                                <br />
                                <b>FOR</b> <b>INSERT</b><br />
                                <b>AS</b><br />
                                DECLARE @rcnt int
                                <br />
                                <b>SELECT</b> @rcnt = @@rowcount<br />
                                <b>IF</b>(<b>SELECT</b> COUNT(*) <b>FROM</b> member,inserted <b>WHERE</b> 
                                member.mem_num = inserted.mem_num)=0<br />
                                BEGIN<br />
                                PRINT &#39;Transaction not processed&#39;<br />
                                PRINT &#39;No entry for this member&#39;<br />
                                ROLLBACK TRANSACTION<br />
                                END<br />
                                <b>IF</b>(<b>SELECT</b> COUNT(*) <b>FROM</b> member,inserted <b>WHERE</b> 
                                member.mem_num = inserted.mem_num)&lt;&gt; @rcnt<br />
                                <br />
                                BEGIN<br />
                                PRINT &#39;Not all adults have an entry in the member table&#39;<br />
                                PRINT &#39;Multi-row insert transaction has been rolled backed&#39;<br />
                                ROLLBACK TRANSACTION<br />
                                END</span></p>
                        </div>
                        <p>
                            CREATE TRIGGER (Transact-SQL)</p>
                        <p>
                            Creates a DML, DDL, or logon trigger. A trigger is a special kind of stored 
                            procedure that automatically executes when an event occurs in the database 
                            server. DML triggers execute when a user tries to modify data through a data 
                            manipulation language (DML) event. DML events are INSERT, UPDATE, or DELETE 
                            statements on a table or view. These triggers fire when any valid event is 
                            fired, regardless of whether or not any table rows are affected. 
                        </p>
                        <p>
                            DDL triggers execute in response to a variety of data definition language (DDL) 
                            events. These events primarily correspond to Transact-SQL CREATE, ALTER, and 
                            DROP statements, and certain system stored procedures that perform DDL-like 
                            operations. Logon triggers fire in response to the LOGON event that is raised 
                            when a user sessions is being established. Triggers can be created directly from 
                            Transact-SQL statements or from methods of assemblies that are created in the 
                            Microsoft&nbsp;.NET Framework common language runtime (CLR) and uploaded to an 
                            instance of SQL Server. SQL Server allows for creating multiple triggers for any 
                            specific statement. 
                        </p>                       
                        
                        <pre>Trigger on an INSERT, UPDATE, or DELETE statement to a table or view (DML Trigger)</pre>
                        <pre>CREATE TRIGGER [ schema_name . ]trigger_name </pre>
                        <pre>ON { table | view } </pre>
                        <pre>[ WITH &lt;dml_trigger_option&gt; [ ,...n ] ]</pre>
                        <pre>{ FOR | AFTER | INSTEAD OF } </pre>
                        <pre>{ [ INSERT ] [ , ] [ UPDATE ] [ , ] [ DELETE ] } </pre>
                        <pre>[ WITH APPEND ] </pre>
                        <pre>[ NOT FOR REPLICATION ] </pre>
                        <pre>AS { sql_statement<span>  </span>[ ; ] [ ,...n ] | EXTERNAL NAME &lt;method specifier [ ; ] &gt; }</pre>
                        <pre></pre>
                        <pre>&lt;dml_trigger_option&gt; ::=</pre>
                        <pre><span>    </span>[ ENCRYPTION ]</pre>
                        <pre><span>    </span>[ EXECUTE AS Clause ]</pre>
                        <pre></pre>
                        <pre>&lt;method_specifier&gt; ::=<span>    </span>assembly_name.class_name.method_nameTrigger on a CREATE, ALTER, DROP, GRANT, DENY, REVOKE, or UPDATE STATISTICS statement (DDL Trigger)</pre>
                        <pre>CREATE TRIGGER trigger_name </pre>
                        <pre>ON { ALL SERVER | DATABASE } </pre>
                        <pre>[ WITH &lt;ddl_trigger_option&gt; [ ,...n ] ]</pre>
                        <pre>{ FOR | AFTER } { event_type | event_group } [ ,...n ]</pre>
                        <pre>AS { sql_statement<span>  </span>[ ; ] [ ,...n ] | EXTERNAL NAME &lt; method specifier &gt;<span>  </span>[ ; ] }</pre>
                        <pre></pre>
                        <pre>&lt;ddl_trigger_option&gt; ::=</pre>
                        <pre><span>    </span>[ ENCRYPTION ]</pre>
                        <pre><span>    </span>[ EXECUTE AS Clause ]</pre>
                        <pre></pre>
                        <pre>&lt;method_specifier&gt; ::=<span>    </span>assembly_name.class_name.method_nameTrigger on a LOGON event (Logon Trigger)</pre>
                        <pre>CREATE TRIGGER trigger_name </pre>
                        <pre>ON ALL SERVER </pre>
                        <pre>[ WITH &lt;logon_trigger_option&gt; [ ,...n ] ]</pre>
                        <pre>{ FOR| AFTER } LOGON<span>  </span></pre>
                        <pre>AS { sql_statement<span>  </span>[ ; ] [ ,...n ] | EXTERNAL NAME &lt; method specifier &gt;<span>  </span>[ ; ] }</pre>
                        <pre></pre>
                        <pre>&lt;logon_trigger_option&gt; ::=</pre>
                        <pre><span>    </span>[ ENCRYPTION ]</pre>
                        <pre><span>    </span>[ EXECUTE AS Clause ]</pre>
                        <pre></pre>
                        <pre>&lt;method_specifier&gt; ::=<span>    </span>assembly_name.class_name.method_name</pre>
                        
                        <p>
                            <span class="parameter">schema_name </span>
                        </p>
                        <p>
                            Is the name of the schema to which a DML trigger belongs. DML triggers are 
                            scoped to the schema of the table or view on which they are created.
                            <span class="parameter">schema_name</span> cannot be specified for DDL or logon 
                            triggers.</p>
                        <p>
                            <span class="parameter">trigger_name </span>
                        </p>
                        <p>
                            Is the name of the trigger. A <span class="parameter">trigger_name</span> must 
                            comply with the rules for
                            <a href="http://technet.microsoft.com/en-us/library/ms175874.aspx">identifiers</a>, 
                            except that <span class="parameter">trigger_name</span> cannot start with # or 
                            ##.</p>
                        <p>
                            <span class="parameter">table </span>| <span class="parameter">view</span></p>
                        <p>
                            Is the table or view on which the DML trigger is executed and is sometimes 
                            referred to as the trigger table or trigger view. Specifying the fully qualified 
                            name of the table or view is optional. A view can be referenced only by an 
                            INSTEAD OF trigger. DML triggers cannot be defined on local or global temporary 
                            tables.</p>
                        <p>
                            DATABASE 
                        </p>
                        <p>
                            Applies the scope of a DDL trigger to the current database. If specified, the 
                            trigger fires whenever <span class="parameter">event_type</span> or
                            <span class="parameter">event_group</span> occurs in the current database.</p>
                        <p>
                            ALL SERVER 
                        </p>
                        <p>
                            Applies the scope of a DDL or logon trigger to the current server. If specified, 
                            the trigger fires whenever <span class="parameter">event_type</span> or
                            <span class="parameter">event_group</span> occurs anywhere in the current 
                            server.</p>
                        <p>
                            WITH ENCRYPTION 
                        </p>
                        <p>
                            Obfuscates the text of the CREATE TRIGGER statement. Using WITH ENCRYPTION 
                            prevents the trigger from being published as part of SQL Server replication. 
                            WITH ENCRYPTION cannot be specified for CLR triggers.</p>
                        <p>
                            EXECUTE AS</p>
                        <p>
                            Specifies the security context under which the trigger is executed. Enables you 
                            to control which user account the instance of SQL Server uses to validate 
                            permissions on any database objects that are referenced by the trigger.</p>
                        
                        <p>
                            FOR | AFTER 
                        </p>
                        <p>
                            AFTER specifies that the DML trigger is fired only when all operations specified 
                            in the triggering SQL statement have executed successfully. All referential 
                            cascade actions and constraint checks also must succeed before this trigger 
                            fires.</p>
                        <p>
                            AFTER is the default when FOR is the only keyword specified. 
                        </p>
                        <p>
                            AFTER triggers cannot be defined on views. 
                        </p>
                        <p>
                            INSTEAD OF 
                        </p>
                        <p>
                            Specifies that the DML trigger is executed <span class="parameter">instead of
                            </span>the triggering SQL statement, therefore, overriding the actions of the 
                            triggering statements. INSTEAD OF cannot be specified for DDL or logon triggers.</p>
                        <p>
                            At most, one INSTEAD OF trigger per INSERT, UPDATE, or DELETE statement can be 
                            defined on a table or view. However, you can define views on views where each 
                            view has its own INSTEAD OF trigger. 
                        </p>
                        <p>
                            INSTEAD OF triggers are not allowed on updatable views that use WITH CHECK 
                            OPTION. SQL Server raises an error when an INSTEAD OF trigger is added to an 
                            updatable view WITH CHECK OPTION specified. The user must remove that option by 
                            using ALTER VIEW before defining the INSTEAD OF trigger. 
                        </p>
                        <p>
                            { [ DELETE ] [ , ] [ INSERT ] [ , ] [ UPDATE ] } 
                        </p>
                        <p>
                            Specifies the data modification statements that activate the DML trigger when it 
                            is tried against this table or view. At least one option must be specified. Any 
                            combination of these options in any order is allowed in the trigger definition.</p>
                        <p>
                            For INSTEAD OF triggers, the DELETE option is not allowed on tables that have a 
                            referential relationship specifying a cascade action ON DELETE. Similarly, the 
                            UPDATE option is not allowed on tables that have a referential relationship 
                            specifying a cascade action ON UPDATE. 
                        </p>
                        <p>
                            <span class="parameter">event_type </span>
                        </p>
                        <p>
                            Is the name of a Transact-SQL language event that, after execution, causes a DDL 
                            trigger to fire. Valid events for DDL triggers are listed in
                            <a href="http://technet.microsoft.com/en-us/library/bb522542.aspx">DDL Events</a>.</p>
                        <p>
                            <span class="parameter">event_group </span>
                        </p>
                        <p>
                            Is the name of a predefined grouping of Transact-SQL language events. The DDL 
                            trigger fires after execution of any Transact-SQL language event that belongs to
                            <span class="parameter">event_group</span>. Valid event groups for DDL triggers 
                            are listed in <a href="http://technet.microsoft.com/en-us/library/bb510452.aspx">
                            DDL Event Groups</a>. 
                        </p>
                        <p>
                            After the CREATE TRIGGER has finished running, <span class="parameter">
                            event_group</span> also acts as a macro by adding the event types it covers to 
                            the sys.trigger_events catalog view.</p>
                        <p>
                            WITH APPEND 
                        </p>
                        <p>
                            Specifies that an additional trigger of an existing type should be added. WITH 
                            APPEND cannot be used with INSTEAD OF triggers or if AFTER trigger is explicitly 
                            stated. WITH APPEND can be used only when FOR is specified, without INSTEAD OF 
                            or AFTER, for backward compatibility reasons. WITH APPEND cannot be specified if 
                            EXTERNAL NAME is specified (that is, if the trigger is a CLR trigger).</p>
                        <p>
                                        WITH APPEND will be removed in the next version of MicrosoftSQL Server. Do not 
                                        use WITH APPEND in new development work, and plan to modify applications that 
                                        currently use it.</p>
                        <p>
                            NOT FOR REPLICATION 
                        </p>
                        <p>
                            Indicates that the trigger should not be executed when a replication agent 
                            modifies the table that is involved in the trigger. For more information, see
                            <a href="http://technet.microsoft.com/en-us/library/ms152529.aspx">Controlling 
                            Constraints, Identities, and Triggers with NOT FOR REPLICATION</a>.</p>
                        <p>
                            <span class="parameter">sql_statement </span>
                        </p>
                        <p>
                            Is the trigger conditions and actions. Trigger conditions specify additional 
                            criteria that determine whether the tried DML, DDL, or logon events cause the 
                            trigger actions to be performed.</p>
                        <p>
                            The trigger actions specified in the Transact-SQL statements go into effect when 
                            the operation is tried. 
                        </p>
                        <p>
                            Triggers can include any number and kind of Transact-SQL statements, with 
                            exceptions. For more information, see Remarks. A trigger is designed to check or 
                            change data based on a data modification or definition statement; it should not 
                            return data to the user. The Transact-SQL statements in a trigger frequently 
                            include <a href="http://technet.microsoft.com/en-us/library/ms174290.aspx">
                            control-of-flow language</a>. 
                        </p>
                        <p>
                            DML triggers use the deleted and inserted logical (conceptual) tables. They are 
                            structurally similar to the table on which the trigger is defined, that is, the 
                            table on which the user action is tried. The deleted and inserted tables hold 
                            the old values or new values of the rows that may be changed by the user action. 
                            For example, to retrieve all values in the <span class="code">deleted</span> 
                            table, use: 
                        </p>
                        <pre>SELECT *</pre>
                        <pre>FROM deleted</pre>
                        <p>
                            For more information, see
                            <a href="http://technet.microsoft.com/en-us/library/ms191300.aspx">Using the 
                            inserted and deleted Tables</a>. 
                        </p>
                        <p>
                            DDL and logon triggers capture information about the triggering event by using 
                            the <a href="http://technet.microsoft.com/en-us/library/ms173781.aspx">EVENTDATA 
                            (Transact-SQL)</a> function. For more information, see
                            <a href="http://technet.microsoft.com/en-us/library/ms187909.aspx">Using the 
                            EVENTDATA Function</a>. 
                        </p>
                        <p>
                            SQL Server allows for the update of <span class="input">text</span>,
                            <span class="input">ntext</span>, or <span class="input">image</span> columns 
                            through the INSTEAD OF trigger on tables or views. 
                        </p>
                        
                        <p>
                            &lt; method_specifier &gt; 
                        </p>
                        <p>
                            For a CLR trigger, specifies the method of an assembly to bind with the trigger. 
                            The method must take no arguments and return void. <span class="parameter">
                            class_name</span> must be a valid SQL Server identifier and must exist as a 
                            class in the assembly with assembly visibility. If the class has a 
                            namespace-qualified name that uses &#39;.&#39; to separate namespace parts, the class 
                            name must be delimited by using [ ] or &quot; &quot; delimiters. The class cannot be a 
                            nested class. 
                        </p>                        
                        
                        <h3>
                            DML Triggers</h3>
                        <p>
                            DML triggers are frequently used for enforcing business rules and data 
                            integrity. SQL Server provides declarative referential integrity (DRI) through 
                            the ALTER TABLE and CREATE TABLE statements. However, DRI does not provide 
                            cross-database referential integrity. Referential integrity refers to the rules 
                            about the relationships between the primary and foreign keys of tables. To 
                            enforce referential integrity, use the PRIMARY KEY and FOREIGN KEY constraints 
                            in ALTER TABLE and CREATE TABLE. If constraints exist on the trigger table, they 
                            are checked after the INSTEAD OF trigger execution and before the AFTER trigger 
                            execution. If the constraints are violated, the INSTEAD OF trigger actions are 
                            rolled back and the AFTER trigger is not fired.</p>
                        <p>
                            The first and last AFTER triggers to be executed on a table can be specified by 
                            using sp_settriggerorder. Only one first and one last AFTER trigger for each 
                            INSERT, UPDATE, and DELETE operation can be specified on a table. If there are 
                            other AFTER triggers on the same table, they are randomly executed.</p>
                        <p>
                            If an ALTER TRIGGER statement changes a first or last trigger, the first or last 
                            attribute set on the modified trigger is dropped, and the order value must be 
                            reset by using sp_settriggerorder.</p>
                        <p>
                            An AFTER trigger is executed only after the triggering SQL statement has 
                            executed successfully. This successful execution includes all referential 
                            cascade actions and constraint checks associated with the object updated or 
                            deleted. 
                        </p>
                        <p>
                            If an INSTEAD OF trigger defined on a table executes a statement against the 
                            table that would ordinarily fire the INSTEAD OF trigger again, the trigger is 
                            not called recursively. Instead, the statement is processed as if the table had 
                            no INSTEAD OF trigger and starts the chain of constraint operations and AFTER 
                            trigger executions. For example, if a trigger is defined as an INSTEAD OF INSERT 
                            trigger for a table, and the trigger executes an INSERT statement on the same 
                            table, the INSERT statement executed by the INSTEAD OF trigger does not call the 
                            trigger again. The INSERT executed by the trigger starts the process of 
                            performing constraint actions and firing any AFTER INSERT triggers defined for 
                            the table.</p>
                        <p>
                            If an INSTEAD OF trigger defined on a view executes a statement against the view 
                            that would ordinarily fire the INSTEAD OF trigger again, it is not called 
                            recursively. Instead, the statement is resolved as modifications against the 
                            base tables underlying the view. In this case, the view definition must meet all 
                            the restrictions for an updatable view. For a definition of updatable views, see
                            <a href="http://technet.microsoft.com/en-us/library/ms180800.aspx">Modifying 
                            Data Through a View</a>. 
                        </p>
                        <p>
                            For example, if a trigger is defined as an INSTEAD OF UPDATE trigger for a view, 
                            and the trigger executes an UPDATE statement referencing the same view, the 
                            UPDATE statement executed by the INSTEAD OF trigger does not call the trigger 
                            again. The UPDATE executed by the trigger is processed against the view as if 
                            the view did not have an INSTEAD OF trigger. The columns changed by the UPDATE 
                            must be resolved to a single base table. Each modification to an underlying base 
                            table starts the chain of applying constraints and firing AFTER triggers defined 
                            for the table.</p>
                        <h4>
                            Testing for UPDATE or INSERT Actions to Specific Columns</h4>
                        <p>
                            You can design a Transact-SQL trigger to perform certain actions based on UPDATE 
                            or INSERT modifications to specific columns. Use
                            <a href="http://technet.microsoft.com/en-us/library/ms187326.aspx">UPDATE()</a> 
                            or <a href="http://technet.microsoft.com/en-us/library/ms186329.aspx">
                            COLUMNS_UPDATED</a> in the body of the trigger for this purpose. UPDATE() tests 
                            for UPDATE or INSERT tries on one column. COLUMNS_UPDATED tests for UPDATE or 
                            INSERT actions that are performed on multiple columns and returns a bit pattern 
                            that indicates which columns were inserted or updated. 
                        </p>
                        <h4>
                            Trigger Limitations</h4>
                        <p>
                            CREATE TRIGGER must be the first statement in the batch and can apply to only 
                            one table.</p>
                        <p>
                            A trigger is created only in the current database; however, a trigger can 
                            reference objects outside the current database.</p>
                        <p>
                            If the trigger schema name is specified to qualify the trigger, qualify the 
                            table name in the same way.</p>
                        <p>
                            The same trigger action can be defined for more than one user action (for 
                            example, INSERT and UPDATE) in the same CREATE TRIGGER statement.</p>
                        <p>
                            INSTEAD OF DELETE/UPDATE triggers cannot be defined on a table that has a 
                            foreign key with a cascade on DELETE/UPDATE action defined.</p>
                        <p>
                            Any SET statement can be specified inside a trigger. The SET option selected 
                            remains in effect during the execution of the trigger and then reverts to its 
                            former setting.</p>
                        <p>
                            When a trigger fires, results are returned to the calling application, just like 
                            with stored procedures. To prevent having results returned to an application 
                            because of a trigger firing, do not include either SELECT statements that return 
                            results or statements that perform variable assignment in a trigger. A trigger 
                            that includes either SELECT statements that return results to the user or 
                            statements that perform variable assignment requires special handling; these 
                            returned results would have to be written into every application in which 
                            modifications to the trigger table are allowed. If variable assignment must 
                            occur in a trigger, use a SET NOCOUNT statement at the start of the trigger to 
                            prevent the return of any result sets.</p>
                        <p>
                            Although a TRUNCATE TABLE statement is in effect a DELETE statement, it does not 
                            activate a trigger because the operation does not log individual row deletions. 
                            However, only those users with permissions to execute a TRUNCATE TABLE statement 
                            need be concerned about inadvertently circumventing a DELETE trigger this way.</p>
                        <p>
                            The WRITETEXT statement, whether logged or unlogged, does not activate a 
                            trigger.</p>
                        <p>
                            The following Transact-SQL statements are not allowed in a DML trigger:</p>
                        <table border="0" cellpadding="0" >
                            <tr>
                                <td>
                                    <p>
                                        ALTER DATABASE</p>
                                </td>
                                <td>
                                    <p>
                                        CREATE DATABASE</p>
                                </td>
                                <td>
                                    <p>
                                        DROP DATABASE</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>
                                        LOAD DATABASE</p>
                                </td>
                                <td>
                                    <p>
                                        LOAD LOG</p>
                                </td>
                                <td>
                                    <p>
                                        RECONFIGURE</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>
                                        RESTORE DATABASE</p>
                                </td>
                                <td>
                                    <p>
                                        RESTORE LOG</p>
                                </td>
                                <td>
                                    <p>
                                        &nbsp;</p>
                                </td>
                            </tr>
                        </table>
                        <p>
                            Additionally, the following Transact-SQL statements are not allowed inside the 
                            body of a DML trigger when it is used against the table or view that is the 
                            target of the triggering action.</p>
                        <table border="0" cellpadding="0" >
                            <tr>
                                <td>
                                    <p>
                                        CREATE INDEX (including CREATE SPATIAL INDEX and CREATE XML INDEX)</p>
                                </td>
                                <td>
                                    <p>
                                        ALTER INDEX</p>
                                </td>
                                <td>
                                    <p>
                                        DROP INDEX</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>
                                        DBCC DBREINDEX</p>
                                </td>
                                <td>
                                    <p>
                                        ALTER PARTITION FUNCTION</p>
                                </td>
                                <td>
                                    <p>
                                        DROP TABLE</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>
                                        ALTER TABLE when used to do the following:</p>
                                    <p>
                                        Add, modify, or drop columns.</p>
                                    <p>
                                        Switch partitions.</p>
                                    <p>
                                        Add or drop PRIMARY KEY or UNIQUE constraints.</p>
                                </td>
                                
                            </tr>
                            
                            <tr>
                                <td colspan="3">
                                    <p>
                                        Because SQL Server does not support user-defined triggers on system tables, we 
                                        recommend that you do not create user-defined triggers on system tables.</p>
                                </td>
                            </tr>
                        </table>
                        <h3>
                            DDL Triggers</h3>
                        <p>
                            DDL triggers, like standard triggers, execute stored procedures in response to 
                            an event. But unlike standard triggers, they do not execute in response to 
                            UPDATE, INSERT, or DELETE statements on a table or view. Instead, they primarily 
                            execute in response to data definition language (DDL) statements. These include 
                            CREATE, ALTER, DROP, GRANT, DENY, REVOKE, and UPDATE STATISTICS statements. 
                            Certain system stored procedures that perform DDL-like operations can also fire 
                            DDL triggers. 
                        </p>
                        <p>
                                        Test your DDL triggers to determine their responses to system stored procedure 
                                        execution. For example, the CREATE TYPE statement and the sp_addtype and 
                                        sp_rename stored procedures will fire a DDL trigger that is created on a 
                                        CREATE_TYPE event.</p>
                        <p>
                            For more information about DDL triggers, see
                            <a href="http://technet.microsoft.com/en-us/library/ms190989.aspx">DDL Triggers</a>.

                        </p>
                        <p>
                            DDL triggers do not fire in response to events that affect local or global 
                            temporary tables and stored procedures.</p>
                        <p>
                            Unlike DML triggers, DDL triggers are not scoped to schemas. Therefore, 
                            functions such as OBJECT_ID, OBJECT_NAME, OBJECTPROPERTY, and OBJECTPROPERTYEX 
                            cannot be used for querying metadata about DDL triggers. Use the catalog views 
                            instead. For more information, see
                            <a href="http://technet.microsoft.com/en-us/library/ms184304.aspx">Getting 
                            Information About DDL Triggers</a>.</p>
                        <p>
                                        Server-scoped DDL triggers appear in the SQL Server Management Studio Object 
                                        Explorer in the <span class="label">Triggers</span> folder. This folder is 
                                        located under the <span class="label">Server Objects</span> folder. 
                                        Database-scoped DDL Triggers appear in the <span class="label">Database Triggers</span> 
                                        folder. This folder is located under the <span class="label">Programmability</span> 
                                        folder of the corresponding database.</p>
                        <h3>
                            Logon Triggers</h3>
                        <p>
                            Logon triggers execute stored procedures in response to a LOGON event. This 
                            event is raised when a user session is established with an instance of SQL 
                            Server. Logon triggers fire after the authentication phase of logging in 
                            finishes, but before the user session is actually established. Therefore, all 
                            messages originating inside the trigger that would typically reach the user, 
                            such as error messages and messages from the PRINT statement, are diverted to 
                            the SQL Server error log. For more information, see
                            <a href="http://technet.microsoft.com/en-us/library/bb326598.aspx">Logon 
                            Triggers</a>.

                        </p>
                        <p>
                            Logon triggers do not fire if authentication fails. 
                        </p>
                        <p>
                            Distributed transactions are not supported in a logon trigger. Error 3969 is 
                            returned when a logon trigger containing a distributed transaction is fired.</p>
                        <h3>
                            General Trigger Considerations</h3>
                        <h4>
                            Returning Results</h4>
                        <p>
                            The ability to return results from triggers will be removed in a future version 
                            of SQL Server. Triggers that return result sets may cause unexpected behavior in 
                            applications that are not designed to work with them. Avoid returning result 
                            sets from triggers in new development work, and plan to modify applications that 
                            currently do this. To prevent triggers from returning result sets, set the
                            <a href="http://technet.microsoft.com/en-us/library/ms186337.aspx">disallow 
                            results from triggers option</a> to 1.</p>
                        <p>
                            Logon triggers always disallow results sets to be returned and this behavior is 
                            not configurable. If a logon trigger does generate a result set, the trigger 
                            fails to execute and the login attempt that fired the trigger is denied.</p>
                        <h4>
                            Multiple Triggers</h4>
                        <p>
                            SQL Server allows for multiple triggers to be created for each DML, DDL, or 
                            LOGON event. For example, if CREATE TRIGGER FOR UPDATE is executed for a table 
                            that already has an UPDATE trigger, an additional update trigger is created. In 
                            earlier versions of SQL Server, only one trigger for each INSERT, UPDATE, or 
                            DELETE data modification event is allowed for each table.</p>
                        <h4>
                            Recursive Triggers</h4>
                        <p>
                            SQL Server also allows for recursive invocation of triggers when the 
                            RECURSIVE_TRIGGERS setting is enabled using ALTER DATABASE.</p>
                        <p>
                            Recursive triggers enable the following types of recursion to occur: 
                        </p>
                        <p>
                            Indirect recursion</p>
                        <p>
                            With indirect recursion, an application updates table T1. This fires trigger 
                            TR1, updating table T2. In this scenario, trigger T2 then fires and updates 
                            table T1.</p>
                        <p>
                            Direct recursion</p>
                        <p>
                            With direct recursion, the application updates table T1. This fires trigger TR1, 
                            updating table T1. Because table T1 was updated, trigger TR1 fires again, and so 
                            on.</p>
                        <p>
                            The following example uses both indirect and direct trigger recursion Assume 
                            that two update triggers, TR1 and TR2, are defined on table T1. Trigger TR1 
                            updates table T1 recursively. An UPDATE statement executes each TR1 and TR2 one 
                            time. Additionally, the execution of TR1 triggers the execution of TR1 
                            (recursively) and TR2. The inserted and deleted tables for a specific trigger 
                            contain rows that correspond only to the UPDATE statement that invoked the 
                            trigger.</p>
                        <p>
                                        The previous behavior occurs only if the RECURSIVE_TRIGGERS setting is enabled 
                                        by using ALTER DATABASE. There is no defined order in which multiple triggers 
                                        defined for a specific event are executed. Each trigger should be 
                                        self-contained.</p>
                        <p>
                            Disabling the RECURSIVE_TRIGGERS setting only prevents direct recursions. To 
                            disable indirect recursion also, set the nested triggers server option to 0 by 
                            using sp_configure.</p>
                        <p>
                            If any one of the triggers performs a ROLLBACK TRANSACTION, regardless of the 
                            nesting level, no more triggers are executed.</p>
                        <h4>
                            Nested Triggers</h4>
                        <p>
                            Triggers can be nested to a maximum of 32 levels. If a trigger changes a table 
                            on which there is another trigger, the second trigger is activated and can then 
                            call a third trigger, and so on. If any trigger in the chain sets off an 
                            infinite loop, the nesting level is exceeded and the trigger is canceled. When a 
                            Transact-SQL trigger executes managed code by referencing a CLR routine, type, 
                            or aggregate, this reference counts as one level against the 32-level nesting 
                            limit. Methods invoked from within managed code do not count against this limit</p>
                        <p>
                            To disable nested triggers, set the nested triggers option of sp_configure to 0 
                            (off). The default configuration allows for nested triggers. If nested triggers 
                            is off, recursive triggers is also disabled, regardless of the 
                            RECURSIVE_TRIGGERS setting set by using ALTER DATABASE. 
                        </p>
                        <p>
                                        In SQL Server 2000, any AFTER trigger nested inside an INSTEAD OF trigger does 
                                        not fire when the <span class="input">nested triggers</span> server 
                                        configuration option is off. In SQL Server 2005 or later, the first AFTER 
                                        trigger nested inside an INSTEAD OF trigger fires even if the
                                        <span class="input">nested triggers</span> server configuration option is set to 
                                        0. However, under this setting, later AFTER triggers do not fire. We recommend 
                                        that you review your applications for nested triggers to determine whether the 
                                        applications still comply with your business rules with regard to this behavior 
                                        when the <span class="input">nested triggers</span> server configuration option 
                                        is set to 0, and then make appropriate modifications.</p>
                        <h4>
                            Deferred Name Resolution</h4>
                        <p>
                            SQL Server allows for Transact-SQL stored procedures, triggers, and batches to 
                            refer to tables that do not exist at compile time. This ability is called 
                            deferred name resolution. However, if the Transact-SQL stored procedure, 
                            trigger, or batch refers to a table that is defined in the stored procedure or 
                            trigger, a warning is issued at creation time only if the compatibility level 
                            setting is 65. A warning is issued at compile time if a batch is used. An error 
                            message is returned at run time when the table referenced does not exist. For 
                            more information, see
                            <a href="http://technet.microsoft.com/en-us/library/ms190686.aspx">Deferred Name 
                            Resolution and Compilation</a>.</p>
                        
                        <p>
                            To create a DML trigger requires ALTER permission on the table or view on which 
                            the trigger is being created.</p>
                        <p>
                            To create a DDL trigger with server scope (ON ALL SERVER) or a logon trigger 
                            requires CONTROL SERVER permission on the server. To create a DDL trigger with 
                            database scope (ON DATABASE) requires ALTER ANY DATABASE DDL TRIGGER permission 
                            in the current database. 
                        </p>
                        
                        <h3>
                            A. Using a DML trigger with a reminder message</h3>
                        <p>
                            The following DML trigger prints a message to the client when anyone tries to 
                            add or change data in the <span class="code">Customer</span> table.</p>
                        <p>
                            SQL 
                        </p>
                        <pre>USE AdventureWorks2008R2;</pre>
                        <pre>GO</pre>
                        <pre>IF OBJECT_ID (&#39;Sales.reminder1&#39;, &#39;TR&#39;) IS NOT NULL</pre>
                        <pre><span>   </span>DROP TRIGGER Sales.reminder1;</pre>
                        <pre>GO</pre>
                        <pre>CREATE TRIGGER reminder1</pre>
                        <pre>ON Sales.Customer</pre>
                        <pre>AFTER INSERT, UPDATE </pre>
                        <pre>AS RAISERROR (&#39;Notify Customer Relations&#39;, 16, 10);</pre>
                        <pre>GO</pre>
                        <h3>
                            B. Using a DML trigger with a reminder e-mail message</h3>
                        <p>
                            The following example sends an e-mail message to a specified person (<span 
                                class="code">MaryM</span>) when the <span class="code">Customer</span> table 
                            changes.</p>
                        <p>
                            SQL 
                        </p>
                        <pre>USE AdventureWorks2008R2;</pre>
                        <pre>GO</pre>
                        <pre>IF OBJECT_ID (&#39;Sales.reminder2&#39;,&#39;TR&#39;) IS NOT NULL</pre>
                        <pre><span>    </span>DROP TRIGGER Sales.reminder2;</pre>
                        <pre>GO</pre>
                        <pre>CREATE TRIGGER reminder2</pre>
                        <pre>ON Sales.Customer</pre>
                        <pre>AFTER INSERT, UPDATE, DELETE </pre>
                        <pre>AS</pre>
                        <pre><span>   </span>EXEC msdb.dbo.sp_send_dbmail</pre>
                        <pre><span>        </span>@profile_name = &#39;AdventureWorks2008R2 Administrator&#39;,</pre>
                        <pre><span>        </span>@recipients = &#39;danw@Adventure-Works.com&#39;,</pre>
                        <pre><span>        </span>@body = &#39;Don&#39;&#39;t forget to print a report for the sales force.&#39;,</pre>
                        <pre><span>        </span>@subject = &#39;Reminder&#39;;</pre>
                        <pre>GO</pre>
                        <h3>
                            C. Using a DML AFTER trigger to enforce a business rule between the 
                            PurchaseOrderHeader and Vendor tables</h3>
                        <p>
                            Because CHECK constraints can reference only the columns on which the 
                            column-level or table-level constraint is defined, any cross-table constraints 
                            (in this case, business rules) must be defined as triggers.</p>
                        <p>
                            The following example creates a DML trigger. This trigger checks to make sure 
                            the credit rating for the vendor is good when an attempt is made to insert a new 
                            purchase order into the <span class="code">PurchaseOrderHeader</span> table. To 
                            obtain the credit rating of the vendor, the <span class="code">Vendor</span> 
                            table must be referenced. If the credit rating is too low, a message is 
                            displayed and the insertion does not execute.</p>
                        
                        <p>
                            SQL 
                        </p>
                        <pre>USE AdventureWorks2008R2;</pre>
                        <pre>GO</pre>
                        <pre>IF OBJECT_ID (&#39;Purchasing.LowCredit&#39;,&#39;TR&#39;) IS NOT NULL</pre>
                        <pre><span>   </span>DROP TRIGGER Purchasing.LowCredit;</pre>
                        <pre>GO</pre>
                        <pre>-- This trigger prevents a row from being inserted in the Purchasing.PurchaseOrderHeader table</pre>
                        <pre>-- when the credit rating of the specified vendor is set to 5 (below average).</pre>
                        <pre></pre>
                        <pre>CREATE TRIGGER Purchasing.LowCredit ON Purchasing.PurchaseOrderHeader</pre>
                        <pre>AFTER INSERT</pre>
                        <pre>AS</pre>
                        <pre>DECLARE @creditrating tinyint, @vendorid int;</pre>
                        <pre>IF EXISTS (SELECT *</pre>
                        <pre><span>           </span>FROM Purchasing.PurchaseOrderHeader p </pre>
                        <pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>JOIN inserted AS i </pre>
                        <pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>ON p.PurchaseOrderID = i.PurchaseOrderID </pre>
                        <pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>JOIN Purchasing.Vendor AS v </pre>
                        <pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>ON v.BusinessEntityID = p.VendorID</pre>
                        <pre><span>           </span>WHERE v.CreditRating = 5</pre>
                        <pre><span>          </span>)</pre>
                        <pre>BEGIN</pre>
                        <pre>RAISERROR (&#39;This vendor&#39;&#39;s credit rating is too low to accept new purchase orders.&#39;, 16, 1);</pre>
                        <pre>ROLLBACK TRANSACTION;</pre>
                        <pre>RETURN </pre>
                        <pre>END;</pre>
                        <pre></pre>
                        <pre>GO</pre>
                        <pre>-- This statement attempts to insert a row into the PurchaseOrderHeader table</pre>
                        <pre>-- for a vendor that has a below average credit rating.</pre>
                        <pre>-- The AFTER INSERT trigger is fired and the INSERT transaction is rolled back.</pre>
                        <pre></pre>
                        <pre>INSERT INTO Purchasing.PurchaseOrderHeader (RevisionNumber, Status, EmployeeID,</pre>
                        <pre>VendorID, ShipMethodID, OrderDate, ShipDate, SubTotal, TaxAmt, Freight)</pre>
                        <pre>VALUES(</pre>
                        <pre>2</pre>
                        <pre>,3</pre>
                        <pre>,261<span>    </span></pre>
                        <pre>,1652<span>    </span></pre>
                        <pre>,4<span>    </span></pre>
                        <pre>,GETDATE()</pre>
                        <pre>,GETDATE()</pre>
                        <pre>,44594.55<span>    </span></pre>
                        <pre>,3567.564<span>    </span></pre>
                        <pre>,1114.8638);</pre>
                        <pre>GO</pre>
                        <h3>
                            D. Using a database-scoped DDL trigger</h3>
                        <p>
                            The following example uses a DDL trigger to prevent any synonym in a database 
                            from being dropped.</p>
                        <p>
                            SQL 
                        </p>
                        <pre>USE AdventureWorks2008R2;</pre>
                        <pre>GO</pre>
                        <pre>IF EXISTS (SELECT * FROM sys.triggers</pre>
                        <pre><span>    </span>WHERE parent_class = 0 AND name = &#39;safety&#39;)</pre>
                        <pre>DROP TRIGGER safety</pre>
                        <pre>ON DATABASE;</pre>
                        <pre>GO</pre>
                        <pre>CREATE TRIGGER safety </pre>
                        <pre>ON DATABASE </pre>
                        <pre>FOR DROP_SYNONYM</pre>
                        <pre>AS </pre>
                        <pre><span>&nbsp;&nbsp;&nbsp;</span>RAISERROR (&#39;You must disable Trigger &quot;safety&quot; to drop synonyms!&#39;,10, 1)</pre>
                        <pre><span>   </span>ROLLBACK</pre>
                        <pre>GO</pre>
                        <pre>DROP TRIGGER safety</pre>
                        <pre>ON DATABASE;</pre>
                        <pre>GO</pre>
                        <pre></pre>
                        <h3>
                            E. Using a server-scoped DDL trigger</h3>
                        <p>
                            The following example uses a DDL trigger to print a message if any CREATE 
                            DATABASE event occurs on the current server instance, and uses the
                            <span class="code">EVENTDATA</span> function to retrieve the text of the 
                            corresponding Transact-SQL statement.</p>
                        
                        <p>
                            SQL 
                        </p>
                        <pre>IF EXISTS (SELECT * FROM sys.server_triggers</pre>
                        <pre><span>    </span>WHERE name = &#39;ddl_trig_database&#39;)</pre>
                        <pre>DROP TRIGGER ddl_trig_database</pre>
                        <pre>ON ALL SERVER;</pre>
                        <pre>GO</pre>
                        <pre>CREATE TRIGGER ddl_trig_database </pre>
                        <pre>ON ALL SERVER </pre>
                        <pre>FOR CREATE_DATABASE </pre>
                        <pre>AS </pre>
                        <pre><span>&nbsp;&nbsp;&nbsp;&nbsp;</span>PRINT &#39;Database Created.&#39;</pre>
                        <pre><span>    </span>SELECT EVENTDATA().value(&#39;(/EVENT_INSTANCE/TSQLCommand/CommandText)[1]&#39;,&#39;nvarchar(max)&#39;)</pre>
                        <pre>GO</pre>
                        <pre>DROP TRIGGER ddl_trig_database</pre>
                        <pre>ON ALL SERVER;</pre>
                        <pre>GO</pre>
                        <h3>
                            F. Using a logon trigger</h3>
                        <p>
                            The following logon trigger example denies an attempt to log in to SQL Server as 
                            a member of the <span class="parameter">login_test</span> login if there are 
                            already three user sessions running under that login.</p>
                        <p>
                            SQL 
                        </p>
                        <pre>USE master;</pre>
                        <pre>GO</pre>
                        <pre>CREATE LOGIN login_test WITH PASSWORD = &#39;3KHJ6dhx(0xVYsdf&#39; MUST_CHANGE,</pre>
                        <pre><span>    </span>CHECK_EXPIRATION = ON;</pre>
                        <pre>GO</pre>
                        <pre>GRANT VIEW SERVER STATE TO login_test;</pre>
                        <pre>GO</pre>
                        <pre>CREATE TRIGGER connection_limit_trigger</pre>
                        <pre>ON ALL SERVER WITH EXECUTE AS &#39;login_test&#39;</pre>
                        <pre>FOR LOGON</pre>
                        <pre>AS</pre>
                        <pre>BEGIN</pre>
                        <pre>IF ORIGINAL_LOGIN()= &#39;login_test&#39; AND</pre>
                        <pre><span>    </span>(SELECT COUNT(*) FROM sys.dm_exec_sessions</pre>
                        <pre><span>            </span>WHERE is_user_process = 1 AND</pre>
                        <pre><span>                </span>original_login_name = &#39;login_test&#39;) <span>&gt;</span> 3</pre>
                        <pre><span>    </span>ROLLBACK;</pre>
                        <pre>END;</pre>
                        <h3>
                            G. Viewing the events that cause a trigger to fire</h3>
                        <p>
                            The following example queries the <span class="code">sys.triggers</span> and
                            <span class="code">sys.trigger_events</span> catalog views to determine which 
                            Transact-SQL language events cause trigger <span class="code">safety</span> to 
                            fire. <span class="code">safety</span> is created in the previous example. 
                        </p>
                        <p>
                            SQL 
                        </p>
                        <pre>SELECT TE.*</pre>
                        <pre>FROM sys.trigger_events AS TE</pre>
                        <pre>JOIN sys.triggers AS T</pre>
                        <pre>ON T.object_id = TE.object_id</pre>
                        <pre>WHERE T.parent_class = 0</pre>
                        <pre>AND T.name = &#39;safety&#39;</pre>
                        <pre>GO</pre>
                        
						
                    </div>
				</section>
            </div>
        </div>
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="inner">
                <!-- Logo -->
                <section id="search" class="alt">
					<header>
							<h4><a href="http://softwaredevelopersolution.com">Software Developer Solution</a></h4>
						</header>
				</section>
                <!-- Menu -->
                <nav id="menu">
					<header class="major">
						<h2>Menu</h2>
					</header>
					<ul>
						
                        <li>
							<span class="opener active">SQL</span>
							<ul>
								<li><a href="/sql/index.html">sql</a></li>
                                <li><a href="/sql/SelfJoins.html">Self-Joins</a></li>
                                <li><a href="/sql/ClusteredIndex.html">Clustered Index</a></li>
                                <li><a href="/sql/VarcharAndNVarchar.html">Varchar And NVarchar</a></li>
                                <li><a href="/sql/TableUserDefinedFunction.html">Table Valued User Defined Function</a></li>
                                <li><a href="/sql/TriggersSQLSERVER.html">Triggers in SQL SERVER</a></li>
							</ul>
						</li>
						<li><a href="/sharepoint/index.html">sharepoint</a></li>
                        <li><a href="/aspnet/index.html">asp.net</a></li>
                        <li><a href="/Powershell/index.html">Powershell</a></li>                    
                        <li><a href="/html/index.html">html</a></li>
                        <li><a href="/css/index.html">css</a></li>
                        <li><a href="/javascript/index.html">java script</a></li>
                        <li><a href="/bootstrap/index.html">bootstrap</a></li>
                        <li><a href="/jquery/index.html">jquery</a></li>
                        <li><a href="/IQ/index.html">Interview Question</a></li>
					</ul>
				</nav>
                <!-- Footer -->
                <footer id="footer">
					<p class="copyright">&copy; All rights reserved. <a href="http://softwaredevelopersolution.com">Software Developer Solution</a>.</p>
				</footer>
            </div>
        </div>
    </div>
    <!-- Scripts -->
    <script src="/../assets/js/jquery.min.js"></script>
    <script src="/../assets/js/browser.min.js"></script>
    <script src="/../assets/js/breakpoints.min.js"></script>
    <script src="/../assets/js/util.js"></script>
    <script src="/../assets/js/main.js"></script>
</body>
</html>
